# -*- coding: utf-8 -*-
"""cyclic_peptide_rosetta_dockipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ryqKu4Tnqq6atpX8p9jkydKfyT-PtBR7
"""

# Install dependencies and Rosetta (assuming you have access to PyRosetta)
_ = !pip install biopython
_ = !pip install pyrosettacolabsetup py3dmol git+https://github.com/RosettaCommons/pyrosetta_viewer3d.git
import pyrosettacolabsetup; pyrosettacolabsetup.install_pyrosetta()

import pyrosetta
from pyrosetta.rosetta.protocols.docking import DockMCMProtocol
from pyrosetta.rosetta.utility import vector1_int
from pyrosetta.rosetta.core.scoring import ScoreFunction
import os
from Bio import PDB
from typing import List, Tuple
import random
import py3Dmol

def initialize_rosetta(extra_options: List[str] = None) -> None:
    """Initialize PyRosetta with optional extra options."""
    init_options = ["-ex1", "-ex2", "-use_input_sc", "-ignore_unrecognized_res",
                   "-restore_talaris_behavior", "-no_optH false"]
    if extra_options:
        init_options.extend(extra_options)
    pyrosetta.init(' '.join(init_options))

def prepare_protein(protein_path: str, chains: str) -> pyrosetta.Pose:
    """
    Prepare protein target for docking.
    Args:
        protein_path: Path to protein PDB file
        chains: String of chain IDs to keep (e.g. 'AB')
    """
    pose = pyrosetta.pose_from_pdb(protein_path)

    if chains:  # Changed from chains != ""
        # Create selection vector for all residues - fixed constructor
        selection_vector = pyrosetta.rosetta.utility.vector1_bool(pose.total_residue())
        for i in range(1, len(selection_vector) + 1):
            selection_vector[i] = False

        # Select residues from each specified chain
        for chain in chains:
            chain_selector = pyrosetta.rosetta.core.select.residue_selector.ChainSelector(chain)
            chain_vector = chain_selector.apply(pose)

            # Add this chain's residues to our selection
            for i in range(1, len(chain_vector) + 1):
                if chain_vector[i]:
                    selection_vector[i] = True

        # Get the selected residues
        selected_residues = pyrosetta.rosetta.core.select.residue_selector.ResidueVector()
        for i, selected in enumerate(selection_vector, 1):
            if selected:
                selected_residues.append(i)

        # Create a new pose with only selected chains
        new_pose = pyrosetta.Pose()
        pyrosetta.rosetta.core.pose.pdbslice(new_pose, pose, selected_residues)
        return new_pose

    return pose

def prepare_cyclic_peptide(peptide_path: str, chains: str) -> pyrosetta.Pose:
    """
    Prepare cyclic peptide for docking.
    Args:
        peptide_path: Path to peptide PDB file
        chains: String of chain IDs to keep (e.g. 'C')
    """
    pose = pyrosetta.pose_from_pdb(peptide_path)

    if chains:  # Changed from chains != ""
        # Create selection vector for all residues - fixed constructor
        selection_vector = pyrosetta.rosetta.utility.vector1_bool(pose.total_residue())
        for i in range(1, len(selection_vector) + 1):
            selection_vector[i] = False

        # Rest of the function remains identical to prepare_protein
        for chain in chains:
            chain_selector = pyrosetta.rosetta.core.select.residue_selector.ChainSelector(chain)
            chain_vector = chain_selector.apply(pose)

            for i in range(1, len(chain_vector) + 1):
                if chain_vector[i]:
                    selection_vector[i] = True

        selected_residues = pyrosetta.rosetta.core.select.residue_selector.ResidueVector()
        for i, selected in enumerate(selection_vector, 1):
            if selected:
                selected_residues.append(i)

        new_pose = pyrosetta.Pose()
        pyrosetta.rosetta.core.pose.pdbslice(new_pose, pose, selected_residues)
        return new_pose

    return pose

def setup_docking_protocol(
    score_function: str = "ref2015"
) -> Tuple[pyrosetta.rosetta.protocols.docking.DockMCMProtocol, pyrosetta.ScoreFunction]:
    """Setup docking protocol and scoring function."""
    sf = pyrosetta.create_score_function(score_function)
    sf_pack = pyrosetta.create_score_function(score_function)
    dock_prot = pyrosetta.rosetta.protocols.docking.DockMCMProtocol(1, sf, sf_pack)
    return dock_prot, sf

def perform_docking(
    peptide_pose: pyrosetta.Pose,
    protein_pose: pyrosetta.Pose,
    protein_chains: str,
    peptide_chains: str,
    n_decoys: int = 100
) -> List[Tuple[pyrosetta.Pose, float]]:
    """
    Perform docking simulation and return sorted results.
    Args:
        peptide_pose: Pose object of the cyclic peptide
        protein_pose: Pose object of the protein complex
        protein_chains: String of chains in protein to use for docking (e.g. 'AB')
        peptide_chains: String of chains in peptide to use for docking (e.g. 'C')
        n_decoys: Number of docking decoys to generate
    """
    docking, sf = setup_docking_protocol()
    results = []

    # Combine poses
    docking_pose = pyrosetta.Pose()
    docking_pose.assign(protein_pose)
    docking_pose.append_pose_by_jump(peptide_pose, 1)

    # Set up docking partners using specified chains
    docking.set_partners(f"{protein_chains}_{peptide_chains}")

    # Generate decoys
    for i in range(n_decoys):
        current_pose = docking_pose.clone()
        docking.apply(current_pose)
        score = sf(current_pose)
        results.append((current_pose.clone(), score))
        print(f"Completed decoy {i+1}/{n_decoys}, Score: {score:.2f}")

    results.sort(key=lambda x: x[1])
    return results

def save_results(results: List[Tuple[pyrosetta.Pose, float]], output_dir: str) -> None:
    """Save docking results to PDB files."""
    os.makedirs(output_dir, exist_ok=True)

    for i, (pose, score) in enumerate(results[:10]):  # Save top 10 results
        output_path = os.path.join(output_dir, f"docking_result_{i+1}_score_{score:.2f}.pdb")
        pose.dump_pdb(output_path)
        print(f"Saved result {i+1} to {output_path}")

def visualize_result(pose: pyrosetta.Pose, width: int = 800, height: int = 600) -> None:
    """
    Visualize a docking result using py3Dmol.
    """
    # Create a temporary PDB file
    temp_pdb = "temp_visualization.pdb"
    pose.dump_pdb(temp_pdb)

    # Create viewer
    view = py3Dmol.view(width=width, height=height)

    # Load structure
    with open(temp_pdb, 'r') as f:
        pdb_data = f.read()

    view.addModel(pdb_data, "pdb")

    # Style the protein (first chain)
    view.setStyle({'chain': 'A'}, {'cartoon': {'color': 'gray'}})

    # Style the peptide (second chain)
    view.setStyle({'chain': 'B'}, {
        'cartoon': {'color': 'spectrum'},
        'stick': {'colorscheme': 'spectrum'}
    })

    # Set view options
    view.zoomTo()

    # Remove temporary file
    os.remove(temp_pdb)

    # Display the view
    view.show()

def main():
    # Initialize Rosetta
    initialize_rosetta()

    # Paths to your input files (modify these)
    protein_path = "/content/NDIA.pdb"
    peptide_path = "/content/LDN3.pdb"
    output_dir = "docking_results"
    protein_chains = "AB"
    peptide_chains = "A"

    # Prepare structures
    protein_pose = prepare_protein(protein_path, chains=protein_chains)
    peptide_pose = prepare_cyclic_peptide(peptide_path, chains=peptide_chains)

    # Perform docking
    results = perform_docking(peptide_pose, protein_pose, protein_chains, peptide_chains, n_decoys=100)

    # Save results
    save_results(results, output_dir)

    # Visualize the best result
    print("\nVisualizing best docking result:")
    visualize_result(results[0][0])

    print("Docking completed successfully!")

if __name__ == "__main__":
    main()